1. 创建顶层父类 Object.h Object.cpp
    a. 让数据结构库中所有的类都继承自该Object类
    b. 定义动态内存申请的行为，提高代码的移植性
    c. 将析构函数声明为纯虚函数，因为Object应该被当做是一个抽象类，不该被创建，
    注意：这里需要给出纯虚函数的定义，否在子类在析构的时候会出错。
2. 创建智能指针模板类 SmartPointer.h
    a. 需要注意在使用拷贝构造函数过着赋值操作符的时候，需要进行指针所有权的转换。
    b. 在进行所有权交换的时候，需要用const_cast来去除对象的const属性，否则所有权转换无法成功进行
    c. 对于*操作符的重载，使用了两个版本，一个const版本，一个非const版本，返回值需要注意
3. 异常类的构建
4. 创建线性表抽象父类
    在该抽象父类中，有一个纯虚函数virtual int capacity() const = 0;在这里起到了两个作用
    ① 因为这里定义的是一个抽象类，所以需要纯虚函数的支持
    ② 因为两个子类中得到线性表最大容量的方式不同，所以这里将他们进行一个抽象，定义出一个相同的接口，
    因此在父类就不需要关心到底是哪个子类调用了该函数。（虚函数的支持）

    const放在成员函数末尾不仅代表在该成员函数中不能修改成员变量，还表示调用该函数的对象
    可能是const对象。

    对于容器类来说，我们可以禁用其赋值操作符和拷贝构造函数，一种做法是将抽象父类的拷贝
    构造函数和赋值操作符放入私有或者保护成员中，但这时需要注意，应当显示的声明其无参数的
    构造函数，因为无参数的默认构造函数会被其他的构造函数覆盖，导致子类的构造函数调用的时候出错

5. 创建数组类
    a. 我们创建了连个使用的数组类模板，一个是静态数组类模板，即数组创建好后，大小就无法改变了，
    一个是动态数组类模板，即创建好后，数组的大小还可以改变。
    b. 首先创建数组类的抽象父类，和创建SeqList这个抽象父类的考虑方法类似，我们首先需要将数组这个
    概念抽象出来，即父类只管操作这块抽象出来的空间，而空间怎么实现，则交由两个子类不同的实现方法。
    数组大小这个概念也抽象出来，父类只管调用这个接口，其实现由子类来完成（因为两个子类的到数组大小
    的方法也不一样，需要分别实现，但是他们的接口完全相同）。

6. 链表类的构建
    a. 我们将创建普通的存放在堆上的链表，也将创建一个容纳固定个数元素个数的链表，并且存放元素的空间不
    位于堆空间上，因为频繁地向系统申请释放堆空间会产生大量的内存碎片。
    b. 由于除了上面a提到的一方面之外，两种链表实现的方法完全相同，因此和前面的相同，父类使用一个接口，
    具体的实现交由子类来完成
    c. 综合上面两点，我们需要将每次创建这个节点的行为抽象出来，并且分别实现，有了节点的创建，所以也需要
    考虑的节点的销毁。
    d. 之前有写过使一个类能够将对象创建在一个指定的内存空间上（例如堆空间，静态存储区，栈），那时候只需要
    将new，delete操作符重载即可，但是在这里StaticLinkList中不能做到，因为Node这个类是在这个抽象父类
    LinkList声明的，它不可能知道子类StaticLinkList中的一片预留的空间，所以只能通过重载一个继承自Node
    节点的新的类SNode的new操作符（SNode继承自Node，除了重载了new操作符之外，其他属性和行为与Node完全相同）
    再加上虚函数的技术来实现。

    ① 我们在创建头结点的时候，不应该使用和普通节点一样的类型，因为头结点只是一个标记，如果该链表存放的是
    一个自定义类型，那么我们创建头结点的时候将会调用该类型的构造函数，这并不是我们所期望的，所以我们需要对其
    进行优化，具体见代码LinkList.h。

7. 链表和线性表的对比分析
    a. 插入和删除
     - 顺序表：涉及大量数据元素的复制操作
     - 链表：只涉及指针操作，效率与具体的数据类型是什么无关

    b. 数据访问
     - 顺序表：随机访问，可直接定位
     - 链表：只能够进行顺序访问

    c. 工程中的选择
     - 顺序表：
        数据元素相对简单，不涉及到深拷贝
        数据相对稳定，访问操作远多于插入和删除操作
     - 链表：
        数据元素类型相对复杂，复制操作比较耗时
        数据元素不稳定，会经常进项插入和删除操作

